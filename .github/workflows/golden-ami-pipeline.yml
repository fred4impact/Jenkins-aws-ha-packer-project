name: Golden AMI Build and Scan Pipeline

on:
  push:
    branches:
      - master
      - feature
    paths:
      - 'packer/**'
      - 'playbooks/**'
      - '.github/workflows/**'
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      build_ami:
        description: 'Build new AMI'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  AWS_REGION: us-east-1
  PACKER_VERSION: 1.10.0
  TERRAFORM_VERSION: 1.6.0
  TRIVY_VERSION: latest
  ANSIBLE_VERSION: latest

jobs:
  # ============================================
  # STAGE I: CHECKOUT
  # ============================================
  checkout:
    name: Stage I - Checkout Playbook and Code
    runs-on: ubuntu-latest
    outputs:
      timestamp: ${{ steps.set-timestamp.outputs.timestamp }}
      build_id: ${{ steps.set-timestamp.outputs.build_id }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          path: repository

      - name: Set build metadata
        id: set-timestamp
        run: |
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          BUILD_ID="build-${TIMESTAMP}"
          echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
          echo "build_id=${BUILD_ID}" >> $GITHUB_OUTPUT
          echo "‚úÖ Build ID: ${BUILD_ID}"

      - name: Verify playbook structure
        run: |
          echo "=== Verifying Playbook Structure ==="
          ls -la repository/playbooks/ || echo "‚ö†Ô∏è Playbooks directory not found"
          ls -la repository/packer/ || echo "‚ö†Ô∏è Packer directory not found"
          echo "‚úÖ Checkout completed"

      - name: Upload repository as artifact
        uses: actions/upload-artifact@v4
        with:
          name: repository
          path: repository
          retention-days: 7

  # ============================================
  # STAGE II: BUILD AMI WITH PACKER
  # ============================================
  build_ami:
    name: Stage II - Build Golden AMI with Packer
    runs-on: ubuntu-latest
    needs: checkout
    if: github.event.inputs.build_ami != 'false'
    outputs:
      ami_id: ${{ steps.extract-ami-id.outputs.ami_id }}
      ami_name: ${{ steps.extract-ami-id.outputs.ami_name }}
    steps:
      - name: Download repository artifact
        uses: actions/download-artifact@v4
        with:
          name: repository
          path: .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Packer
        uses: hashicorp/setup-packer@main
        with:
          version: ${{ env.PACKER_VERSION }}

      - name: Install Ansible
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip
          pip3 install ansible

      - name: Verify tools installation
        run: |
          echo "=== Verifying Tools ==="
          packer version
          ansible --version
          aws --version

      - name: Initialize Packer plugins
        working-directory: ./packer
        run: |
          echo "=== Initializing Packer Plugins ==="
          packer init .

      - name: Validate Packer configuration
        working-directory: ./packer
        run: |
          echo "=== Validating Packer Configuration ==="
          # Set default values if not provided via repository variables
          JENKINS_VERSION="${JENKINS_VERSION:-2.414.3}"
          JAVA_VERSION="${JAVA_VERSION:-17}"
          
          # Validate all .pkr.hcl files in the directory (this loads variables.pkr.hcl automatically)
          packer validate \
            -var "aws_region=${{ env.AWS_REGION }}" \
            -var "jenkins_version=${JENKINS_VERSION}" \
            -var "java_version=${JAVA_VERSION}" \
            . || exit 1
          echo "‚úÖ Packer configuration is valid"

      - name: Build Golden AMI with Packer
        id: build-ami
        working-directory: ./packer
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
          PACKER_LOG: 1
          PACKER_LOG_PATH: packer.log
        run: |
          echo "=== Building Golden AMI ==="
          echo "Base AMI: Ubuntu 22.04"
          echo "Provisioner: Ansible"
          echo "Components: Jenkins, Java, Ubuntu, playbook"
          
          # Set default values if not provided via repository variables
          JENKINS_VERSION="${JENKINS_VERSION:-2.414.3}"
          JAVA_VERSION="${JAVA_VERSION:-17}"
          
          # Build using . to load all .pkr.hcl files (including variables.pkr.hcl)
          packer build \
            -var "aws_region=${{ env.AWS_REGION }}" \
            -var "jenkins_version=${JENKINS_VERSION}" \
            -var "java_version=${JAVA_VERSION}" \
            .
          
          echo "‚úÖ AMI build completed"

      - name: Extract AMI ID from manifest
        id: extract-ami-id
        working-directory: ./packer
        run: |
          echo "=== Extracting AMI ID ==="
          if [ -f manifest.json ]; then
            # Get the latest build (last one in the builds array)
            LAST_RUN_UUID=$(jq -r '.last_run_uuid' manifest.json)
            echo "Last run UUID: ${LAST_RUN_UUID}"
            
            # Find the build with matching UUID, or use the last build
            ARTIFACT_ID=$(jq -r --arg uuid "$LAST_RUN_UUID" '.builds[] | select(.packer_run_uuid == $uuid) | .artifact_id' manifest.json)
            
            # If not found by UUID, get the last build
            if [ -z "${ARTIFACT_ID}" ] || [ "${ARTIFACT_ID}" == "null" ]; then
              echo "‚ö†Ô∏è Build not found by UUID, using last build in array"
              ARTIFACT_ID=$(jq -r '.builds[-1].artifact_id' manifest.json)
            fi
            
            # Extract AMI ID (format: region:ami-id)
            AMI_ID=$(echo "${ARTIFACT_ID}" | cut -d':' -f2)
            REGION=$(echo "${ARTIFACT_ID}" | cut -d':' -f1)
            
            # Get AMI name from the build
            AMI_NAME=$(jq -r --arg uuid "$LAST_RUN_UUID" '.builds[] | select(.packer_run_uuid == $uuid) | .name' manifest.json)
            if [ -z "${AMI_NAME}" ] || [ "${AMI_NAME}" == "null" ]; then
              AMI_NAME=$(jq -r '.builds[-1].name' manifest.json)
            fi
            
            echo "ami_id=${AMI_ID}" >> $GITHUB_OUTPUT
            echo "ami_name=${AMI_NAME}" >> $GITHUB_OUTPUT
            echo "ami_region=${REGION}" >> $GITHUB_OUTPUT
            echo "‚úÖ AMI ID: ${AMI_ID}"
            echo "‚úÖ AMI Name: ${AMI_NAME}"
            echo "‚úÖ AMI Region: ${REGION}"
          else
            echo "‚ùå Error: manifest.json not found"
            exit 1
          fi

      - name: Wait for AMI to be available
        run: |
          echo "=== Waiting for AMI to be available ==="
          AMI_ID="${{ steps.extract-ami-id.outputs.ami_id }}"
          AWS_REGION="${{ steps.extract-ami-id.outputs.ami_region || env.AWS_REGION }}"
          MAX_ATTEMPTS=30
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            AMI_STATE=$(aws ec2 describe-images \
              --image-ids ${AMI_ID} \
              --region ${AWS_REGION} \
              --query 'Images[0].State' \
              --output text 2>/dev/null || echo "not-found")
            
            if [ "${AMI_STATE}" == "available" ]; then
              echo "‚úÖ AMI is available!"
              break
            elif [ "${AMI_STATE}" == "not-found" ]; then
              echo "‚è≥ Attempt ${ATTEMPT}/${MAX_ATTEMPTS}: AMI not found yet, waiting..."
            else
              echo "‚è≥ Attempt ${ATTEMPT}/${MAX_ATTEMPTS}: AMI state: ${AMI_STATE}, waiting..."
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
            sleep 5
          done
          
          if [ "${AMI_STATE}" != "available" ]; then
            echo "‚ùå Error: AMI ${AMI_ID} did not become available (state: ${AMI_STATE})"
            exit 1
          fi

      - name: Verify AMI exists in AWS
        run: |
          echo "=== Verifying AMI in AWS ==="
          AMI_ID="${{ steps.extract-ami-id.outputs.ami_id }}"
          AWS_REGION="${{ steps.extract-ami-id.outputs.ami_region || env.AWS_REGION }}"
          
          aws ec2 describe-images \
            --image-ids ${AMI_ID} \
            --region ${AWS_REGION} \
            --query 'Images[0].[ImageId,Name,State,CreationDate]' \
            --output table

      - name: Save AMI ID to file
        run: |
          echo "AMI_ID=${{ steps.extract-ami-id.outputs.ami_id }}" > ami-id.txt
          echo "AMI_NAME=${{ steps.extract-ami-id.outputs.ami_name }}" >> ami-id.txt
          cat ami-id.txt

      - name: Upload AMI metadata
        uses: actions/upload-artifact@v4
        with:
          name: ami-metadata
          path: |
            ami-id.txt
            packer/manifest.json
            packer/packer.log
          retention-days: 30

      - name: Tag AMI with build information
        run: |
          echo "=== Tagging AMI ==="
          aws ec2 create-tags \
            --resources ${{ steps.extract-ami-id.outputs.ami_id }} \
            --tags \
              Key=BuildID,Value=${{ needs.checkout.outputs.build_id }} \
              Key=BuildDate,Value=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
              Key=GitHubRunID,Value=${{ github.run_id }} \
              Key=GitHubSHA,Value=${{ github.sha }} \
              Key=GitHubRef,Value=${{ github.ref }} \
            --region ${{ env.AWS_REGION }}

  # ============================================
  # STAGE III: SCAN AMI WITH TRIVY
  # ============================================
  scan_ami:
    name: Stage III - Scan Golden AMI with Trivy
    runs-on: ubuntu-latest
    needs: [checkout, build_ami]
    if: github.event.inputs.build_ami != 'false'
    outputs:
      scan_passed: ${{ steps.scan-ami.outputs.scan_passed }}
    steps:
      - name: Download AMI metadata
        uses: actions/download-artifact@v4
        with:
          name: ami-metadata
          path: .

      - name: Read AMI ID
        id: read-ami-id
        run: |
          if [ -f ami-id.txt ]; then
            source ami-id.txt
            echo "AMI_ID=${AMI_ID}" >> $GITHUB_ENV
            echo "‚úÖ AMI ID: ${AMI_ID}"
          else
            echo "‚ùå Error: ami-id.txt not found"
            exit 1
          fi

      - name: Configure AWS credentials for Trivy
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AMI exists before scanning
        run: |
          echo "=== Verifying AMI exists ==="
          aws ec2 describe-images \
            --image-ids ${AMI_ID} \
            --region ${{ env.AWS_REGION }} \
            --query 'Images[0].[ImageId,Name,State]' \
            --output table

      - name: Scan AMI with Trivy
        id: scan-ami
        env:
          TRIVY_EXIT_CODE: ${{ vars.TRIVY_EXIT_CODE || '1' }}
          TRIVY_SEVERITY: ${{ vars.TRIVY_SEVERITY || 'HIGH,CRITICAL' }}
        run: |
          echo "=== Scanning AMI with Trivy ==="
          
          # Validate AMI ID is set
          if [ -z "${AMI_ID}" ]; then
            echo "‚ùå Error: AMI_ID is not set"
            exit 1
          fi
          
          echo "AMI ID: ${AMI_ID}"
          echo "Severity: ${TRIVY_SEVERITY:-HIGH,CRITICAL}"
          echo "Exit Code: ${TRIVY_EXIT_CODE:-1}"
          
          # Set default values if not provided
          TRIVY_EXIT_CODE="${TRIVY_EXIT_CODE:-1}"
          TRIVY_SEVERITY="${TRIVY_SEVERITY:-HIGH,CRITICAL}"
          
          # Verify AMI ID format
          if [[ ! "${AMI_ID}" =~ ^ami- ]]; then
            echo "‚ùå Error: Invalid AMI ID format: ${AMI_ID}"
            exit 1
          fi
          
          # Generate table format report
          # Note: Trivy scans AWS AMIs using the format: aws://region/ami-id
          AWS_REGION_VALUE="${{ env.AWS_REGION }}"
          TRIVY_AMI_REF="aws://${AWS_REGION_VALUE}/${AMI_ID}"
          
          echo "Trivy AMI Reference: ${TRIVY_AMI_REF}"
          
          set +e  # Don't exit on error, we'll handle it
          docker run --rm \
            -e AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }} \
            -e AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }} \
            -e AWS_DEFAULT_REGION=${AWS_REGION_VALUE} \
            -v $(pwd):/workspace \
            -w /workspace \
            aquasec/trivy:${{ env.TRIVY_VERSION }} \
            image \
            --exit-code ${TRIVY_EXIT_CODE} \
            --severity "${TRIVY_SEVERITY}" \
            --format table \
            --output trivy-report.txt \
            "${TRIVY_AMI_REF}" 2>&1 | tee trivy-scan.log || SCAN_FAILED=true
          set -e  # Re-enable exit on error
          
          # Check if scan actually ran (not just command error)
          if [ "${SCAN_FAILED}" = "true" ]; then
            # Check if it's a vulnerability issue or command error
            if [ -f trivy-report.txt ] && [ -s trivy-report.txt ]; then
              echo "scan_passed=false" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Trivy scan found vulnerabilities"
            else
              echo "‚ùå Trivy scan command failed"
              echo "=== Trivy Error Log ==="
              cat trivy-scan.log || true
              echo "======================"
              exit 1
            fi
          else
            echo "scan_passed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Trivy scan passed"
          fi

      - name: Generate JSON report
        env:
          TRIVY_SEVERITY: ${{ vars.TRIVY_SEVERITY || 'HIGH,CRITICAL' }}
        run: |
          echo "=== Generating JSON Report ==="
          TRIVY_SEVERITY="${TRIVY_SEVERITY:-HIGH,CRITICAL}"
          AWS_REGION_VALUE="${{ env.AWS_REGION }}"
          TRIVY_AMI_REF="aws://${AWS_REGION_VALUE}/${AMI_ID}"
          
          docker run --rm \
            -e AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }} \
            -e AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }} \
            -e AWS_DEFAULT_REGION=${AWS_REGION_VALUE} \
            -v $(pwd):/workspace \
            -w /workspace \
            aquasec/trivy:${{ env.TRIVY_VERSION }} \
            image \
            --exit-code 0 \
            --severity "${TRIVY_SEVERITY}" \
            --format json \
            --output trivy-report.json \
            "${TRIVY_AMI_REF}"

      - name: Generate HTML report
        env:
          TRIVY_SEVERITY: ${{ vars.TRIVY_SEVERITY || 'HIGH,CRITICAL' }}
        run: |
          echo "=== Generating HTML Report ==="
          TRIVY_SEVERITY="${TRIVY_SEVERITY:-HIGH,CRITICAL}"
          AWS_REGION_VALUE="${{ env.AWS_REGION }}"
          TRIVY_AMI_REF="aws://${AWS_REGION_VALUE}/${AMI_ID}"
          
          docker run --rm \
            -e AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }} \
            -e AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }} \
            -e AWS_DEFAULT_REGION=${AWS_REGION_VALUE} \
            -v $(pwd):/workspace \
            -w /workspace \
            aquasec/trivy:${{ env.TRIVY_VERSION }} \
            image \
            --exit-code 0 \
            --severity "${TRIVY_SEVERITY}" \
            --format template \
            --template '@contrib/html.tpl' \
            --output trivy-report.html \
            "${TRIVY_AMI_REF}"

      - name: Display scan summary
        run: |
          echo "=== Trivy Scan Summary ==="
          if [ -f trivy-report.txt ]; then
            head -30 trivy-report.txt
          fi

      - name: Upload Trivy reports
        uses: actions/upload-artifact@v4
        with:
          name: trivy-reports
          path: |
            trivy-report.txt
            trivy-report.json
            trivy-report.html
            ami-id.txt
          retention-days: 30

      - name: Upload Trivy report to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: trivy-report.json
          category: trivy-ami-scan
        continue-on-error: true

      - name: Fail if scan failed
        if: steps.scan-ami.outputs.scan_passed == 'false'
        run: |
          echo "‚ùå Trivy scan failed with critical vulnerabilities"
          echo "Please review the trivy-report.html for details"
          exit 1

  # ============================================
  # NOTIFICATION JOB
  # ============================================
  notify:
    name: Pipeline Summary and Notification
    runs-on: ubuntu-latest
    needs: [checkout, build_ami, scan_ami]
    if: always()
    steps:
      - name: Download AMI metadata
        uses: actions/download-artifact@v4
        with:
          name: ami-metadata
          path: .
        continue-on-error: true

      - name: Pipeline Summary
        run: |
          echo "=== Pipeline Summary ==="
          echo "Build ID: ${{ needs.checkout.outputs.build_id }}"
          echo "GitHub Run ID: ${{ github.run_id }}"
          echo "GitHub SHA: ${{ github.sha }}"
          echo "GitHub Ref: ${{ github.ref }}"
          echo ""
          
          if [ -f ami-id.txt ]; then
            source ami-id.txt
            echo "‚úÖ AMI Built: ${AMI_ID}"
            echo "üîó View in AWS: https://console.aws.amazon.com/ec2/v2/home?region=${{ env.AWS_REGION }}#Images:imageId=${AMI_ID}"
          fi
          
          echo "üìä Pipeline: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo ""
          echo "‚ÑπÔ∏è  To deploy infrastructure, use the 'Deploy Infrastructure' workflow"
          echo "   with the AMI ID: ${AMI_ID}"


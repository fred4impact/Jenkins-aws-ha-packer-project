name: Golden AMI Build and Scan Pipeline

on:
  push:
    branches:
      - master
      - feature
    paths:
      - 'packer/**'
      - 'playbooks/**'
      - '.github/workflows/**'
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      build_ami:
        description: 'Build new AMI'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  AWS_REGION: us-east-1
  PACKER_VERSION: 1.10.0
  TERRAFORM_VERSION: 1.6.0
  TRIVY_VERSION: latest
  ANSIBLE_VERSION: latest

jobs:
  # ============================================
  # STAGE I: CHECKOUT
  # ============================================
  checkout:
    name: Stage I - Checkout Playbook and Code
    runs-on: ubuntu-latest
    outputs:
      timestamp: ${{ steps.set-timestamp.outputs.timestamp }}
      build_id: ${{ steps.set-timestamp.outputs.build_id }}
      build_date: ${{ steps.set-timestamp.outputs.build_date }}
      build_number: ${{ steps.set-timestamp.outputs.build_number }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          path: repository

      - name: Set build metadata
        id: set-timestamp
        run: |
          # Get build date (YYYYMMDD format)
          BUILD_DATE=$(date +%Y%m%d)
          
          # Generate build number (incremental based on date + run number)
          # Format: RUN-{run_id} or use run number for incremental
          BUILD_NUMBER="RUN-${{ github.run_number }}"
          
          # Full timestamp for unique IDs
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          BUILD_ID="build-${TIMESTAMP}"
          
          echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
          echo "build_id=${BUILD_ID}" >> $GITHUB_OUTPUT
          echo "build_date=${BUILD_DATE}" >> $GITHUB_OUTPUT
          echo "build_number=${BUILD_NUMBER}" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Build Date: ${BUILD_DATE}"
          echo "‚úÖ Build Number: ${BUILD_NUMBER}"
          echo "‚úÖ Build ID: ${BUILD_ID}"

      - name: Verify playbook structure
        run: |
          echo "=== Verifying Playbook Structure ==="
          ls -la repository/playbooks/ || echo "‚ö†Ô∏è Playbooks directory not found"
          ls -la repository/packer/ || echo "‚ö†Ô∏è Packer directory not found"
          echo "‚úÖ Checkout completed"

      - name: Upload repository as artifact
        uses: actions/upload-artifact@v4
        with:
          name: repository
          path: repository
          retention-days: 7

  # ============================================
  # STAGE II: BUILD AMI WITH PACKER
  # ============================================
  build_ami:
    name: Stage II - Build Golden AMI with Packer
    runs-on: ubuntu-latest
    needs: checkout
    if: github.event.inputs.build_ami != 'false'
    outputs:
      ami_id: ${{ steps.extract-ami-id.outputs.ami_id }}
      ami_name: ${{ steps.extract-ami-id.outputs.ami_name }}
    steps:
      - name: Download repository artifact
        uses: actions/download-artifact@v4
        with:
          name: repository
          path: .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Packer
        uses: hashicorp/setup-packer@main
        with:
          version: ${{ env.PACKER_VERSION }}

      - name: Install Ansible
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip
          pip3 install ansible

      - name: Verify tools installation
        run: |
          echo "=== Verifying Tools ==="
          packer version
          ansible --version
          aws --version

      - name: Initialize Packer plugins
        working-directory: ./packer
        run: |
          echo "=== Initializing Packer Plugins ==="
          packer init .

      - name: Validate Packer configuration
        working-directory: ./packer
        run: |
          echo "=== Validating Packer Configuration ==="
          # Set default values if not provided via repository variables
          JENKINS_VERSION="${JENKINS_VERSION:-2.414.3}"
          JAVA_VERSION="${JAVA_VERSION:-17}"
          BUILD_NUMBER="${{ needs.checkout.outputs.build_number }}"
          
          # Validate all .pkr.hcl files in the directory (this loads variables.pkr.hcl automatically)
          packer validate \
            -var "aws_region=${{ env.AWS_REGION }}" \
            -var "jenkins_version=${JENKINS_VERSION}" \
            -var "java_version=${JAVA_VERSION}" \
            -var "build_number=${BUILD_NUMBER}" \
            . || exit 1
          echo "‚úÖ Packer configuration is valid"

      - name: Build Golden AMI with Packer
        id: build-ami
        working-directory: ./packer
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
          PACKER_LOG: 1
          PACKER_LOG_PATH: packer.log
        run: |
          echo "=== Building Golden AMI ==="
          echo "Base AMI: Ubuntu 22.04"
          echo "Provisioner: Ansible"
          echo "Components: Jenkins, Java, Ubuntu, playbook"
          echo "Build Date: ${{ needs.checkout.outputs.build_date }}"
          echo "Build Number: ${{ needs.checkout.outputs.build_number }}"
          
          # Set default values if not provided via repository variables
          JENKINS_VERSION="${JENKINS_VERSION:-2.414.3}"
          JAVA_VERSION="${JAVA_VERSION:-17}"
          BUILD_NUMBER="${{ needs.checkout.outputs.build_number }}"
          
          # Build using . to load all .pkr.hcl files (including variables.pkr.hcl)
          # AMI name will be: Jenkins-bilarn-HA-AMI-YYYYMMDD-RUN-{number}
          packer build \
            -var "aws_region=${{ env.AWS_REGION }}" \
            -var "jenkins_version=${JENKINS_VERSION}" \
            -var "java_version=${JAVA_VERSION}" \
            -var "build_number=${BUILD_NUMBER}" \
            .
          
          echo "‚úÖ AMI build completed"
          echo "‚úÖ AMI Name Format: Jenkins-bilarn-HA-AMI-${{ needs.checkout.outputs.build_date }}-${BUILD_NUMBER}"

      - name: Extract AMI ID from manifest
        id: extract-ami-id
        working-directory: ./packer
        run: |
          echo "=== Extracting AMI ID ==="
          if [ -f manifest.json ]; then
            # Get the latest build (last one in the builds array)
            LAST_RUN_UUID=$(jq -r '.last_run_uuid' manifest.json)
            echo "Last run UUID: ${LAST_RUN_UUID}"
            
            # Find the build with matching UUID, or use the last build
            ARTIFACT_ID=$(jq -r --arg uuid "$LAST_RUN_UUID" '.builds[] | select(.packer_run_uuid == $uuid) | .artifact_id' manifest.json)
            
            # If not found by UUID, get the last build
            if [ -z "${ARTIFACT_ID}" ] || [ "${ARTIFACT_ID}" == "null" ]; then
              echo "‚ö†Ô∏è Build not found by UUID, using last build in array"
              ARTIFACT_ID=$(jq -r '.builds[-1].artifact_id' manifest.json)
            fi
            
            # Extract AMI ID (format: region:ami-id)
            AMI_ID=$(echo "${ARTIFACT_ID}" | cut -d':' -f2)
            REGION=$(echo "${ARTIFACT_ID}" | cut -d':' -f1)
            
            # Get AMI name from the build
            AMI_NAME=$(jq -r --arg uuid "$LAST_RUN_UUID" '.builds[] | select(.packer_run_uuid == $uuid) | .name' manifest.json)
            if [ -z "${AMI_NAME}" ] || [ "${AMI_NAME}" == "null" ]; then
              AMI_NAME=$(jq -r '.builds[-1].name' manifest.json)
            fi
            
            echo "ami_id=${AMI_ID}" >> $GITHUB_OUTPUT
            echo "ami_name=${AMI_NAME}" >> $GITHUB_OUTPUT
            echo "ami_region=${REGION}" >> $GITHUB_OUTPUT
            echo "‚úÖ AMI ID: ${AMI_ID}"
            echo "‚úÖ AMI Name: ${AMI_NAME}"
            echo "‚úÖ AMI Region: ${REGION}"
          else
            echo "‚ùå Error: manifest.json not found"
            exit 1
          fi

      - name: Wait for AMI to be available
        run: |
          echo "=== Waiting for AMI to be available ==="
          AMI_ID="${{ steps.extract-ami-id.outputs.ami_id }}"
          AWS_REGION="${{ steps.extract-ami-id.outputs.ami_region || env.AWS_REGION }}"
          MAX_ATTEMPTS=30
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            AMI_STATE=$(aws ec2 describe-images \
              --image-ids ${AMI_ID} \
              --region ${AWS_REGION} \
              --query 'Images[0].State' \
              --output text 2>/dev/null || echo "not-found")
            
            if [ "${AMI_STATE}" == "available" ]; then
              echo "‚úÖ AMI is available!"
              break
            elif [ "${AMI_STATE}" == "not-found" ]; then
              echo "‚è≥ Attempt ${ATTEMPT}/${MAX_ATTEMPTS}: AMI not found yet, waiting..."
            else
              echo "‚è≥ Attempt ${ATTEMPT}/${MAX_ATTEMPTS}: AMI state: ${AMI_STATE}, waiting..."
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
            sleep 5
          done
          
          if [ "${AMI_STATE}" != "available" ]; then
            echo "‚ùå Error: AMI ${AMI_ID} did not become available (state: ${AMI_STATE})"
            exit 1
          fi

      - name: Verify AMI exists in AWS
        run: |
          echo "=== Verifying AMI in AWS ==="
          AMI_ID="${{ steps.extract-ami-id.outputs.ami_id }}"
          AWS_REGION="${{ steps.extract-ami-id.outputs.ami_region || env.AWS_REGION }}"
          
          aws ec2 describe-images \
            --image-ids ${AMI_ID} \
            --region ${AWS_REGION} \
            --query 'Images[0].[ImageId,Name,State,CreationDate]' \
            --output table

      - name: Save AMI ID to file
        run: |
          echo "AMI_ID=${{ steps.extract-ami-id.outputs.ami_id }}" > ami-id.txt
          echo "AMI_NAME=${{ steps.extract-ami-id.outputs.ami_name }}" >> ami-id.txt
          cat ami-id.txt

      - name: Upload AMI metadata
        uses: actions/upload-artifact@v4
        with:
          name: ami-metadata
          path: |
            ami-id.txt
            packer/manifest.json
            packer/packer.log
          retention-days: 30

      - name: Tag AMI with build information
        run: |
          echo "=== Tagging AMI ==="
          aws ec2 create-tags \
            --resources ${{ steps.extract-ami-id.outputs.ami_id }} \
            --tags \
              Key=BuildID,Value=${{ needs.checkout.outputs.build_id }} \
              Key=BuildDate,Value=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
              Key=GitHubRunID,Value=${{ github.run_id }} \
              Key=GitHubSHA,Value=${{ github.sha }} \
              Key=GitHubRef,Value=${{ github.ref }} \
            --region ${{ env.AWS_REGION }}

  # ============================================
  # STAGE III: SCAN AMI WITH TRIVY
  # ============================================
  scan_ami:
    name: Stage III - Scan Golden AMI with Trivy
    runs-on: ubuntu-latest
    needs: [checkout, build_ami]
    if: github.event.inputs.build_ami != 'false'
    outputs:
      scan_passed: ${{ steps.scan-ami.outputs.scan_passed }}
    steps:
      - name: Download AMI metadata
        uses: actions/download-artifact@v4
        with:
          name: ami-metadata
          path: .

      - name: Read AMI ID
        id: read-ami-id
        run: |
          if [ -f ami-id.txt ]; then
            source ami-id.txt
            echo "AMI_ID=${AMI_ID}" >> $GITHUB_ENV
            echo "‚úÖ AMI ID: ${AMI_ID}"
          else
            echo "‚ùå Error: ami-id.txt not found"
            exit 1
          fi

      - name: Configure AWS credentials for Trivy
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AMI exists before scanning
        run: |
          echo "=== Verifying AMI exists ==="
          aws ec2 describe-images \
            --image-ids ${AMI_ID} \
            --region ${{ env.AWS_REGION }} \
            --query 'Images[0].[ImageId,Name,State]' \
            --output table

      - name: Scan AMI with Trivy (Optional)
        id: scan-ami
        continue-on-error: true
        env:
          TRIVY_EXIT_CODE: ${{ vars.TRIVY_EXIT_CODE || '1' }}
          TRIVY_SEVERITY: ${{ vars.TRIVY_SEVERITY || 'HIGH,CRITICAL' }}
          ENABLE_TRIVY_SCAN: ${{ vars.ENABLE_TRIVY_SCAN || 'false' }}
        run: |
          echo "=== Scanning AMI with Trivy ==="
          
          # Check if Trivy scanning is enabled
          if [ "${ENABLE_TRIVY_SCAN}" != "true" ]; then
            echo "‚ÑπÔ∏è Trivy AMI scanning is disabled (set ENABLE_TRIVY_SCAN=true to enable)"
            echo "‚ÑπÔ∏è Note: Trivy doesn't natively support AWS AMI scanning"
            echo "‚ÑπÔ∏è Consider scanning instances after deployment or using AWS Inspector"
            echo "scan_passed=true" >> $GITHUB_OUTPUT
            echo "scan_skipped=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Validate AMI ID is set
          if [ -z "${AMI_ID}" ]; then
            echo "‚ùå Error: AMI_ID is not set"
            echo "scan_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "AMI ID: ${AMI_ID}"
          echo "Severity: ${TRIVY_SEVERITY:-HIGH,CRITICAL}"
          echo "Exit Code: ${TRIVY_EXIT_CODE:-1}"
          
          # Set default values if not provided
          TRIVY_EXIT_CODE="${TRIVY_EXIT_CODE:-1}"
          TRIVY_SEVERITY="${TRIVY_SEVERITY:-HIGH,CRITICAL}"
          
          # Verify AMI ID format
          if [[ ! "${AMI_ID}" =~ ^ami- ]]; then
            echo "‚ùå Error: Invalid AMI ID format: ${AMI_ID}"
            echo "scan_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "‚ö†Ô∏è Note: Trivy doesn't natively support AWS AMI scanning"
          echo "‚ö†Ô∏è This scan will be skipped. Consider using:"
          echo "   - AWS Inspector for AMI scanning"
          echo "   - Scanning instances after deployment"
          echo "   - Using container images instead of AMIs"
          
          # Create placeholder reports
          echo "Trivy AMI scanning is not supported. Use AWS Inspector or scan instances post-deployment." > trivy-report.txt
          echo '{"Results":[],"Metadata":{"ScannerName":"trivy","ScannerVersion":"skipped"}' > trivy-report.json
          
          echo "scan_passed=true" >> $GITHUB_OUTPUT
          echo "scan_skipped=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Trivy scan skipped (AMI scanning not supported)"

      - name: Generate JSON report
        if: steps.scan-ami.outputs.scan_skipped != 'true'
        env:
          TRIVY_SEVERITY: ${{ vars.TRIVY_SEVERITY || 'HIGH,CRITICAL' }}
        run: |
          echo "=== Generating JSON Report ==="
          echo "‚ÑπÔ∏è Skipped - Trivy doesn't support AWS AMI scanning"
          echo "‚ÑπÔ∏è JSON report already created in previous step"

      - name: Generate HTML report
        if: steps.scan-ami.outputs.scan_skipped != 'true'
        env:
          TRIVY_SEVERITY: ${{ vars.TRIVY_SEVERITY || 'HIGH,CRITICAL' }}
        run: |
          echo "=== Generating HTML Report ==="
          echo "‚ÑπÔ∏è Skipped - Trivy doesn't support AWS AMI scanning"
          # Create a simple HTML placeholder
          cat > trivy-report.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head><title>Trivy AMI Scan Report</title></head>
          <body>
            <h1>Trivy AMI Scanning Not Supported</h1>
            <p>Trivy does not natively support scanning AWS EC2 AMIs.</p>
            <p>Consider using:</p>
            <ul>
              <li>AWS Inspector for AMI vulnerability scanning</li>
              <li>Scanning EC2 instances after deployment</li>
              <li>Using container images instead of AMIs</li>
            </ul>
          </body>
          </html>
          EOF

      - name: Display scan summary
        run: |
          echo "=== Trivy Scan Summary ==="
          if [ -f trivy-report.txt ]; then
            head -30 trivy-report.txt
          fi

      - name: Upload Trivy reports
        uses: actions/upload-artifact@v4
        with:
          name: trivy-reports
          path: |
            trivy-report.txt
            trivy-report.json
            trivy-report.html
            ami-id.txt
          retention-days: 30

      - name: Upload Trivy report to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: trivy-report.json
          category: trivy-ami-scan
        continue-on-error: true

      - name: Fail if scan failed
        if: |
          steps.scan-ami.outputs.scan_passed == 'false' &&
          steps.scan-ami.outputs.scan_skipped != 'true'
        run: |
          echo "‚ùå Trivy scan failed with critical vulnerabilities"
          echo "Please review the trivy-report.html for details"
          exit 1
      
      - name: Note about AMI scanning
        if: steps.scan-ami.outputs.scan_skipped == 'true'
        run: |
          echo "‚ÑπÔ∏è Trivy AMI Scanning Information:"
          echo "   Trivy doesn't natively support AWS EC2 AMI scanning."
          echo "   Alternative options:"
          echo "   1. Use AWS Inspector for AMI vulnerability assessment"
          echo "   2. Scan EC2 instances after deployment with Trivy"
          echo "   3. Use container images (ECR) which Trivy supports natively"
          echo ""
          echo "   To enable AMI scanning attempts (experimental), set:"
          echo "   Repository variable: ENABLE_TRIVY_SCAN=true"

  # ============================================
  # NOTIFICATION JOB
  # ============================================
  notify:
    name: Pipeline Summary and Notification
    runs-on: ubuntu-latest
    needs: [checkout, build_ami, scan_ami]
    if: always()
    steps:
      - name: Download AMI metadata
        uses: actions/download-artifact@v4
        with:
          name: ami-metadata
          path: .
        continue-on-error: true

      - name: Pipeline Summary
        run: |
          echo "=== Pipeline Summary ==="
          echo "Build ID: ${{ needs.checkout.outputs.build_id }}"
          echo "GitHub Run ID: ${{ github.run_id }}"
          echo "GitHub SHA: ${{ github.sha }}"
          echo "GitHub Ref: ${{ github.ref }}"
          echo ""
          
          if [ -f ami-id.txt ]; then
            source ami-id.txt
            echo "‚úÖ AMI Built: ${AMI_ID}"
            echo "üîó View in AWS: https://console.aws.amazon.com/ec2/v2/home?region=${{ env.AWS_REGION }}#Images:imageId=${AMI_ID}"
          fi
          
          echo "üìä Pipeline: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo ""
          echo "‚ÑπÔ∏è  To deploy infrastructure, use the 'Deploy Infrastructure' workflow"
          echo "   with the AMI ID: ${AMI_ID}"


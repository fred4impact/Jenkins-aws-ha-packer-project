name: Jenkins AWS Infrastructure Lifecycle (Deploy | Destroy)


on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - 'deploy'
          - 'destroy'
      ami_id:
        description: 'AMI ID or Name (required for deploy, optional for destroy)'
        required: false
        type: string
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - 'dev'
          - 'qa'
          - 'staging'
          - 'prod'
      aws_region:
        description: 'AWS Region'
        required: true
        default: 'us-east-1'
        type: choice
        options:
          - 'us-east-1'
          - 'us-west-2'
          - 'eu-west-1'
  push:
    branches:
      - main
      - master
    paths:
      - '.github/workflows/jenkin-aws-infra.yml'
      - 'terraform/**'
  pull_request:
    branches:
      - main
      - master
    paths:
      - '.github/workflows/jenkin-aws-infra.yml'
      - 'terraform/**'
    

env:
  TERRAFORM_VERSION: 1.6.0

jobs:
  # ============================================
  # STAGE IV: DEPLOY/DESTROY INFRASTRUCTURE WITH TERRAFORM
  # ============================================
  deploy_infrastructure:
    name: Stage IV - Deploy/Destroy Infrastructure with Terraform
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    environment:
      name: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      alb_dns: ${{ steps.terraform-output-deploy.outputs.alb_dns || steps.terraform-output-destroy.outputs.alb_dns }}
      efs_id: ${{ steps.terraform-output-deploy.outputs.efs_id || steps.terraform-output-destroy.outputs.efs_id }}
      ami_id: ${{ steps.resolve-ami-deploy.outputs.ami_id || steps.resolve-ami-destroy.outputs.ami_id }}
      action: ${{ github.event.inputs.action }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ github.event.inputs.aws_region || 'us-east-1' }}

      - name: Resolve AMI ID (for deploy only)
        id: resolve-ami-deploy
        if: github.event.inputs.action == 'deploy'
        env:
          AMI_INPUT: ${{ github.event.inputs.ami_id }}
          AWS_REGION: ${{ github.event.inputs.aws_region || 'us-east-1' }}
        run: |
          echo "=== Resolving AMI ID ==="
          
          if [ -z "${AMI_INPUT}" ]; then
            echo "‚ùå Error: AMI ID is required for deployment"
            exit 1
          fi
          
          # Check if input is already an AMI ID (starts with ami-)
          if [[ "${AMI_INPUT}" =~ ^ami- ]]; then
            AMI_ID="${AMI_INPUT}"
            echo "‚úÖ Using provided AMI ID: ${AMI_ID}"
          else
            # Assume it's an AMI name, search for it
            echo "üîç Searching for AMI by name: ${AMI_INPUT}"
            
            # Search for AMI by name
            AMI_ID=$(aws ec2 describe-images \
              --owners self \
              --filters "Name=name,Values=${AMI_INPUT}" "Name=state,Values=available" \
              --query 'Images | sort_by(@, &CreationDate) | [-1].ImageId' \
              --output text \
              --region ${AWS_REGION} 2>/dev/null || echo "")
            
            if [ -z "${AMI_ID}" ] || [ "${AMI_ID}" == "None" ]; then
              echo "‚ùå Error: AMI not found with name '${AMI_INPUT}' in region ${AWS_REGION}"
              echo "Please provide a valid AMI ID (starting with ami-) or AMI name"
              exit 1
            fi
            
            echo "‚úÖ Found AMI ID: ${AMI_ID} for name: ${AMI_INPUT}"
          fi
          
          # Verify AMI exists and is available
          echo "üîç Verifying AMI exists and is available..."
          AMI_STATE=$(aws ec2 describe-images \
            --image-ids ${AMI_ID} \
            --region ${AWS_REGION} \
            --query 'Images[0].State' \
            --output text 2>/dev/null || echo "invalid")
          
          if [ "${AMI_STATE}" != "available" ]; then
            echo "‚ùå Error: AMI ${AMI_ID} is not available (state: ${AMI_STATE})"
            exit 1
          fi
          
          echo "ami_id=${AMI_ID}" >> $GITHUB_OUTPUT
          echo "‚úÖ AMI ID resolved: ${AMI_ID}"
          echo "‚úÖ AMI State: ${AMI_STATE}"
          
          # Display AMI details
          aws ec2 describe-images \
            --image-ids ${AMI_ID} \
            --region ${AWS_REGION} \
            --query 'Images[0].[ImageId,Name,State,CreationDate]' \
            --output table
      
      - name: Set AMI ID for destroy (not required)
        id: resolve-ami-destroy
        if: github.event.inputs.action == 'destroy'
        run: |
          echo "ami_id=" >> $GITHUB_OUTPUT
          echo "‚ö†Ô∏è Destroy action - AMI ID not required"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Determine tfvars file
        id: tfvars-file
        env:
          ENV: ${{ github.event.inputs.environment || 'dev' }}
        run: |
          TFVARS_FILE="${ENV}.tfvars"
          
          # Check if tfvars file exists (from repo root)
          if [ -f "terraform/main/${TFVARS_FILE}" ]; then
            echo "‚úÖ Using environment-specific tfvars file: ${TFVARS_FILE}"
            echo "tfvars_file=${TFVARS_FILE}" >> $GITHUB_OUTPUT
            echo "use_tfvars=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è No ${TFVARS_FILE} found, using variables from workflow inputs and secrets"
            echo "tfvars_file=" >> $GITHUB_OUTPUT
            echo "use_tfvars=false" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Init
        working-directory: ./terraform/main
        run: |
          echo "=== Initializing Terraform ==="
          terraform init

      - name: Terraform Validate
        working-directory: ./terraform/main
        run: |
          echo "=== Validating Terraform Configuration ==="
          terraform validate

      - name: Terraform Plan (Deploy)
        if: github.event.inputs.action == 'deploy'
        working-directory: ./terraform/main
        env:
          TF_VAR_jenkins_ami_id: ${{ steps.resolve-ami-deploy.outputs.ami_id }}
          TF_VAR_aws_region: ${{ github.event.inputs.aws_region || 'us-east-1' }}
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
          TF_VAR_jenkins_admin_user: ${{ secrets.JENKINS_ADMIN_USER || 'admin' }}
          TF_VAR_jenkins_admin_pass: ${{ secrets.JENKINS_ADMIN_PASS }}
        run: |
          echo "=== Creating Terraform Plan (Deploy) ==="
          echo "AMI ID: ${{ steps.resolve-ami-deploy.outputs.ami_id }}"
          echo "Environment: ${{ github.event.inputs.environment || 'dev' }}"
          echo "AWS Region: ${{ github.event.inputs.aws_region || 'us-east-1' }}"
          
          # Verify required secrets are set
          if [ -z "${TF_VAR_jenkins_admin_pass}" ]; then
            echo "‚ùå Error: JENKINS_ADMIN_PASS secret is required but not set"
            echo "Please add JENKINS_ADMIN_PASS to your GitHub repository secrets"
            exit 1
          fi
          
          # Build terraform plan command
          PLAN_CMD="terraform plan"
          
          # Add tfvars file if it exists
          if [ "${{ steps.tfvars-file.outputs.use_tfvars }}" == "true" ]; then
            PLAN_CMD="${PLAN_CMD} -var-file=${{ steps.tfvars-file.outputs.tfvars_file }}"
            echo "Using tfvars file: ${{ steps.tfvars-file.outputs.tfvars_file }}"
          fi
          
          # Add required variables (will override tfvars if specified)
          PLAN_CMD="${PLAN_CMD} -var=\"jenkins_ami_id=${{ steps.resolve-ami-deploy.outputs.ami_id }}\""
          PLAN_CMD="${PLAN_CMD} -var=\"aws_region=${{ github.event.inputs.aws_region || 'us-east-1' }}\""
          PLAN_CMD="${PLAN_CMD} -var=\"environment=${{ github.event.inputs.environment || 'dev' }}\""
          PLAN_CMD="${PLAN_CMD} -var=\"jenkins_admin_user=${TF_VAR_jenkins_admin_user}\""
          PLAN_CMD="${PLAN_CMD} -var=\"jenkins_admin_pass=${TF_VAR_jenkins_admin_pass}\""
          PLAN_CMD="${PLAN_CMD} -out=tfplan"
          
          eval ${PLAN_CMD}
          echo "‚úÖ Terraform plan created successfully"

      - name: Terraform Plan (Destroy)
        if: github.event.inputs.action == 'destroy'
        working-directory: ./terraform/main
        env:
          TF_VAR_aws_region: ${{ github.event.inputs.aws_region || 'us-east-1' }}
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
          TF_VAR_jenkins_admin_user: ${{ secrets.JENKINS_ADMIN_USER || 'admin' }}
          TF_VAR_jenkins_admin_pass: ${{ secrets.JENKINS_ADMIN_PASS }}
        run: |
          echo "=== Creating Terraform Plan (Destroy) ==="
          echo "‚ö†Ô∏è WARNING: This will destroy all infrastructure in environment: ${{ github.event.inputs.environment || 'dev' }}"
          echo "AWS Region: ${{ github.event.inputs.aws_region || 'us-east-1' }}"
          
          # Build terraform plan command
          PLAN_CMD="terraform plan -destroy"
          
          # Add tfvars file if it exists
          if [ "${{ steps.tfvars-file.outputs.use_tfvars }}" == "true" ]; then
            PLAN_CMD="${PLAN_CMD} -var-file=${{ steps.tfvars-file.outputs.tfvars_file }}"
            echo "Using tfvars file: ${{ steps.tfvars-file.outputs.tfvars_file }}"
          else
            # If no tfvars file, ensure required variables are provided
            if [ -z "${TF_VAR_jenkins_admin_pass}" ]; then
              echo "‚ö†Ô∏è Warning: JENKINS_ADMIN_PASS secret not set, but tfvars file not found"
              echo "Terraform may prompt for jenkins_admin_pass if not in state"
            fi
          fi
          
          # Add required variables (tfvars will be used if available)
          PLAN_CMD="${PLAN_CMD} -var=\"aws_region=${{ github.event.inputs.aws_region || 'us-east-1' }}\""
          PLAN_CMD="${PLAN_CMD} -var=\"environment=${{ github.event.inputs.environment || 'dev' }}\""
          if [ -n "${TF_VAR_jenkins_admin_pass}" ]; then
            PLAN_CMD="${PLAN_CMD} -var=\"jenkins_admin_user=${TF_VAR_jenkins_admin_user}\""
            PLAN_CMD="${PLAN_CMD} -var=\"jenkins_admin_pass=${TF_VAR_jenkins_admin_pass}\""
          fi
          PLAN_CMD="${PLAN_CMD} -out=tfplan"
          
          eval ${PLAN_CMD}
          echo "‚úÖ Terraform destroy plan created successfully"

      - name: Terraform Apply (Deploy)
        if: github.event.inputs.action == 'deploy'
        working-directory: ./terraform/main
        env:
          TF_VAR_jenkins_ami_id: ${{ steps.resolve-ami-deploy.outputs.ami_id }}
          TF_VAR_aws_region: ${{ github.event.inputs.aws_region || 'us-east-1' }}
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
          TF_VAR_jenkins_admin_user: ${{ secrets.JENKINS_ADMIN_USER || 'admin' }}
          TF_VAR_jenkins_admin_pass: ${{ secrets.JENKINS_ADMIN_PASS }}
        run: |
          echo "=== Deploying Infrastructure ==="
          echo "Creating:"
          echo "  - VPC, Subnets, IGW, NAT Gateways"
          echo "  - EFS File System"
          echo "  - Application Load Balancer"
          echo "  - Auto Scaling Group"
          echo "  - Launch Template (using Golden AMI: ${{ steps.resolve-ami-deploy.outputs.ami_id }})"
          
          terraform apply -auto-approve tfplan
          echo "‚úÖ Infrastructure deployed successfully"

      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy'
        working-directory: ./terraform/main
        env:
          TF_VAR_aws_region: ${{ github.event.inputs.aws_region || 'us-east-1' }}
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
          TF_VAR_jenkins_admin_user: ${{ secrets.JENKINS_ADMIN_USER || 'admin' }}
          TF_VAR_jenkins_admin_pass: ${{ secrets.JENKINS_ADMIN_PASS }}
        run: |
          echo "=== Destroying Infrastructure ==="
          echo "‚ö†Ô∏è WARNING: Destroying all infrastructure in environment: ${{ github.event.inputs.environment || 'dev' }}"
          echo "This will destroy:"
          echo "  - VPC, Subnets, IGW, NAT Gateways"
          echo "  - EFS File System"
          echo "  - Application Load Balancer"
          echo "  - Auto Scaling Group"
          echo "  - Launch Template"
          echo "  - All EC2 instances"
          
          # Build destroy command
          DESTROY_CMD="terraform destroy -auto-approve"
          
          # Add tfvars file if it exists
          if [ "${{ steps.tfvars-file.outputs.use_tfvars }}" == "true" ]; then
            DESTROY_CMD="${DESTROY_CMD} -var-file=${{ steps.tfvars-file.outputs.tfvars_file }}"
            echo "Using tfvars file: ${{ steps.tfvars-file.outputs.tfvars_file }}"
          else
            # If no tfvars file, ensure required variables are provided
            if [ -n "${TF_VAR_jenkins_admin_pass}" ]; then
              DESTROY_CMD="${DESTROY_CMD} -var=\"jenkins_admin_user=${TF_VAR_jenkins_admin_user}\""
              DESTROY_CMD="${DESTROY_CMD} -var=\"jenkins_admin_pass=${TF_VAR_jenkins_admin_pass}\""
            fi
          fi
          
          # Add required variables
          DESTROY_CMD="${DESTROY_CMD} -var=\"aws_region=${{ github.event.inputs.aws_region || 'us-east-1' }}\""
          DESTROY_CMD="${DESTROY_CMD} -var=\"environment=${{ github.event.inputs.environment || 'dev' }}\""
          
          eval ${DESTROY_CMD}
          echo "‚úÖ Infrastructure destroyed successfully"

      - name: Get Terraform outputs (Deploy only)
        id: terraform-output-deploy
        if: github.event.inputs.action == 'deploy'
        working-directory: ./terraform/main
        run: |
          echo "=== Extracting Terraform Outputs ==="
          ALB_DNS=$(terraform output -raw alb_dns_name 2>/dev/null || echo "")
          EFS_ID=$(terraform output -raw efs_id 2>/dev/null || echo "")
          echo "alb_dns=${ALB_DNS}" >> $GITHUB_OUTPUT
          echo "efs_id=${EFS_ID}" >> $GITHUB_OUTPUT
          echo "‚úÖ ALB DNS: ${ALB_DNS}"
          echo "‚úÖ EFS ID: ${EFS_ID}"
      
      - name: Set empty outputs (Destroy)
        id: terraform-output-destroy
        if: github.event.inputs.action == 'destroy'
        run: |
          echo "alb_dns=" >> $GITHUB_OUTPUT
          echo "efs_id=" >> $GITHUB_OUTPUT

      - name: Upload Terraform state (optional)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: terraform/main/*.tfstate
          retention-days: 90
        continue-on-error: true

  # ============================================
  # STAGE V: POST-DEPLOYMENT CONFIGURATION
  # ============================================
  post_deployment:
    name: Stage V - Post-Deployment Configuration
    runs-on: ubuntu-latest
    needs: [deploy_infrastructure]
    if: |
      needs.deploy_infrastructure.result == 'success' &&
      github.event.inputs.action == 'deploy'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ github.event.inputs.aws_region || 'us-east-1' }}

      - name: Wait for instances to be ready
        run: |
          echo "=== Waiting for Jenkins instances to be ready ==="
          ALB_DNS="${{ needs.deploy_infrastructure.outputs.alb_dns }}"
          MAX_ATTEMPTS=30
          ATTEMPT=0
          
          if [ -z "${ALB_DNS}" ]; then
            echo "‚ö†Ô∏è ALB DNS not available, skipping health check"
            exit 0
          fi
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            if curl -f -s "http://${ALB_DNS}/login" > /dev/null 2>&1; then
              echo "‚úÖ Jenkins is ready!"
              break
            fi
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt ${ATTEMPT}/${MAX_ATTEMPTS}: Waiting for Jenkins..."
            sleep 10
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "‚ö†Ô∏è Jenkins did not become ready in time"
            echo "This may be normal if instances are still starting up"
          fi

      - name: Run post-deployment scripts
        run: |
          echo "=== Running Post-Deployment Scripts ==="
          if [ -d "scripts" ]; then
            echo "‚úÖ Post-deployment scripts directory found"
            # Add your post-deployment script execution here
            # Example: ./scripts/post-deployment.sh
          else
            echo "‚ö†Ô∏è No post-deployment scripts found"
          fi

      - name: Verify deployment
        run: |
          echo "=== Verifying Deployment ==="
          ALB_DNS="${{ needs.deploy_infrastructure.outputs.alb_dns }}"
          EFS_ID="${{ needs.deploy_infrastructure.outputs.efs_id }}"
          AMI_ID="${{ needs.deploy_infrastructure.outputs.ami_id }}"
          
          echo "‚úÖ AMI ID: ${AMI_ID}"
          echo "‚úÖ ALB DNS: ${ALB_DNS}"
          echo "‚úÖ EFS ID: ${EFS_ID}"
          echo ""
          echo "=== Deployment Summary ==="
          echo "Infrastructure deployed successfully!"
          if [ -n "${ALB_DNS}" ]; then
            echo "üåê Jenkins URL: http://${ALB_DNS}"
          fi
          echo ""
          echo "üîó View in AWS Console:"
          echo "   Region: ${{ github.event.inputs.aws_region || 'us-east-1' }}"
          echo "   Environment: ${{ github.event.inputs.environment || 'dev' }}"

  # ============================================
  # NOTIFICATION JOB
  # ============================================
  notify:
    name: Deployment Summary and Notification
    runs-on: ubuntu-latest
    needs: [deploy_infrastructure, post_deployment]
    if: always()
    steps:
      - name: Deployment Summary
        run: |
          echo "=== Deployment Pipeline Summary ==="
          echo "GitHub Run ID: ${{ github.run_id }}"
          echo "GitHub SHA: ${{ github.sha }}"
          echo "GitHub Ref: ${{ github.ref }}"
          echo ""
          echo "Input Parameters:"
          echo "  Action: ${{ github.event.inputs.action }}"
          echo "  AMI ID/Name: ${{ github.event.inputs.ami_id || 'N/A (destroy)' }}"
          echo "  Environment: ${{ github.event.inputs.environment || 'dev' }}"
          echo "  AWS Region: ${{ github.event.inputs.aws_region || 'us-east-1' }}"
          echo ""
          
          if [ "${{ needs.deploy_infrastructure.result }}" == "success" ]; then
            if [ "${{ github.event.inputs.action }}" == "deploy" ]; then
              echo "‚úÖ Infrastructure deployed successfully"
              echo "‚úÖ AMI ID: ${{ needs.deploy_infrastructure.outputs.ami_id }}"
              if [ -n "${{ needs.deploy_infrastructure.outputs.alb_dns }}" ]; then
                echo "üåê Jenkins URL: http://${{ needs.deploy_infrastructure.outputs.alb_dns }}"
              fi
            else
              echo "‚úÖ Infrastructure destroyed successfully"
            fi
          else
            if [ "${{ github.event.inputs.action }}" == "deploy" ]; then
              echo "‚ùå Deployment failed"
            else
              echo "‚ùå Destroy failed"
            fi
          fi
          
          echo ""
          echo "üìä Pipeline: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"


